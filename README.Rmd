---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# neatnet

<!-- badges: start -->
<!-- badges: end -->

The goal of neatnet is to provide a high-performance R implementation for network simplification, combining the "best of" approaches from the Python `neatnet` and `parenx` packages. It uses the `geos` library for efficient geometry operations.

## Installation

You can install the development version of neatnet from GitHub:

``` r
# install.packages("remotes")
remotes::install_github("robinlovelace/neatnet")
```

## Example

This is a basic example showing how to simplify two close parallel lines into a single centerline (skeleton).

```{r example}
library(sf)
library(geos)
# In development, you might source the functions directly if the package isn't installed:
# source("R/neatnet.R") 
# Or assume it is installed:
# library(neatnet)
devtools::load_all()

# Create a simple test case: two parallel lines 5m apart
l1 <- matrix(c(0, 0, 100, 0), ncol = 2, byrow = TRUE)
l2 <- matrix(c(0, 5, 100, 5), ncol = 2, byrow = TRUE)

lines_sf <- st_sf(
  id = 1:2,
  geometry = st_sfc(st_linestring(l1), st_linestring(l2)),
  crs = 27700 # British National Grid (projected, meters)
)

print(lines_sf)

# Run neatnet with default parameters
# dist = 5 (buffer radius). Since lines are 5m apart, they will merge.
simplified <- neatnet(lines_sf, dist = 5)

print(simplified)

# Plotting (basic)
plot(st_geometry(lines_sf), col = "blue", lwd = 2, main = "Original (Blue) vs Simplified (Red)")
plot(st_geometry(simplified), col = "red", lwd = 2, add = TRUE)
```

## Real-world Example (Princes Street, Edinburgh)

This example uses a real-world dataset from the `parenx` package (Princes Street, Edinburgh).

### Python (`parenx`)

The equivalent Python code using `parenx` would be:

```python
import geopandas as gp
from parenx import skeletonize_frame

CRS = "EPSG:27700"
filepath = "rnet_princes_street.geojson"
frame = gp.read_file(filepath).to_crs(CRS)

# buffer=8 corresponds to roughly 16m width
parameter = {"simplify": 0.0, "buffer": 8.0, "scale": 1.0, "knot": False, "segment": False}
r = skeletonize_frame(frame["geometry"], parameter)
```

### R (`neatnet`)

```{r princes-street}
# Load data included in the package
f <- system.file("extdata", "rnet_princes_street.geojson", package = "neatnet")
princes_st <- st_read(f, quiet = TRUE)
princes_st <- st_transform(princes_st, 27700)

print(paste("Original features:", nrow(princes_st)))

# Run neatnet
# dist = 8 matches the Python buffer=8.0
simplified_princes <- neatnet(princes_st, dist = 8)
print(paste("Simplified features:", nrow(simplified_princes)))

# Plot
plot(st_geometry(princes_st), col = "grey", lwd = 3, main = "Princes Street: Original (Grey) vs Simplified (Red)")
plot(st_geometry(simplified_princes), col = "red", lwd = 2, add = TRUE)
```

```{r princes-street-summary}
# Network summaries (features, total length, connected components)

input_summary <- net_summary(princes_st, grid_size = 0.1)
output_summary <- net_summary(simplified_princes, grid_size = 0.1)

print(input_summary)
print(output_summary)
```

## Simplification with sfnetworks (Intersection-First)

The `simplify_network_sfn()` function uses an "intersection-first" approach based on
[sfnetworks](https://luukvdmeer.github.io/sfnetworks/):

1. **Node Clustering (DBSCAN)**: Identifies nodes within `eps` distance as belonging to the same intersection
2. **Node Contraction**: Merges clustered nodes to their centroid, updating edge geometries
3. **Parallel Edge Removal**: Keeps only the shortest edge between each node pair
4. **Dangle Removal**: Removes short dead-end edges
5. **Pseudo-node Smoothing**: Removes degree-2 nodes that just connect two edges

```{r sfnetworks-simplify, fig.width=10, fig.height=8}
library(sfnetworks)
library(tidygraph)
library(dbscan)
library(tibble)
library(geos)

# Compare different eps values with timing
results = list()

# eps = 20
t1 = Sys.time()
results$eps20 = simplify_network_sfn(princes_st, eps = 20)
time_eps20 = round(as.numeric(Sys.time() - t1), 1)

# eps = 35
t1 = Sys.time()
results$eps35 = simplify_network_sfn(princes_st, eps = 35)
time_eps35 = round(as.numeric(Sys.time() - t1), 1)

# eps = 50 (default)
t1 = Sys.time()
results$eps50 = simplify_network_sfn(princes_st, eps = 50)
time_eps50 = round(as.numeric(Sys.time() - t1), 1)

# Summary table
cat("=== sfnetworks Simplification Comparison ===\n\n")
cat(sprintf("%-10s %8s %10s %10s %10s\n", "Variant", "Time(s)", "Features", "Reduction", "Length(km)"))
cat(sprintf("%-10s %8s %10s %10s %10s\n", "--------", "-------", "--------", "---------", "---------"))
cat(sprintf("%-10s %8s %10d %10s %10.1f\n", "Original", "-", nrow(princes_st), "-", 
            sum(as.numeric(st_length(princes_st)))/1000))
cat(sprintf("%-10s %8.1f %10d %10.1f%% %10.1f\n", "eps=20", time_eps20, nrow(results$eps20),
            (1-nrow(results$eps20)/nrow(princes_st))*100, sum(as.numeric(st_length(results$eps20)))/1000))
cat(sprintf("%-10s %8.1f %10d %10.1f%% %10.1f\n", "eps=35", time_eps35, nrow(results$eps35),
            (1-nrow(results$eps35)/nrow(princes_st))*100, sum(as.numeric(st_length(results$eps35)))/1000))
cat(sprintf("%-10s %8.1f %10d %10.1f%% %10.1f\n", "eps=50", time_eps50, nrow(results$eps50),
            (1-nrow(results$eps50)/nrow(princes_st))*100, sum(as.numeric(st_length(results$eps50)))/1000))

# Plot comparison
par(mfrow = c(2, 2))

# Original
plot(st_geometry(princes_st), col = "grey40", lwd = 1, main = "Original (1144 features)")

# eps = 20
plot(st_geometry(princes_st), col = "grey80", lwd = 1, 
     main = paste0("eps=20 (", nrow(results$eps20), " features, ", time_eps20, "s)"))
plot(st_geometry(results$eps20), col = "red", lwd = 2, add = TRUE)

# eps = 35
plot(st_geometry(princes_st), col = "grey80", lwd = 1,
     main = paste0("eps=35 (", nrow(results$eps35), " features, ", time_eps35, "s)"))
plot(st_geometry(results$eps35), col = "blue", lwd = 2, add = TRUE)

# eps = 50
plot(st_geometry(princes_st), col = "grey80", lwd = 1,
     main = paste0("eps=50 (", nrow(results$eps50), " features, ", time_eps50, "s)"))
plot(st_geometry(results$eps50), col = "darkgreen", lwd = 2, add = TRUE)

par(mfrow = c(1, 1))
```

## Comprehensive Benchmark

This section compares all simplification approaches with key metrics.

```{r benchmark-comparison}
# Helper function to count vertices
count_vertices = function(x) {
  sum(sapply(st_geometry(x), function(g) nrow(st_coordinates(g))))
}

# Run all approaches with timing
benchmark = list()

# Original
benchmark$original = list(
  name = "Original",
  time = 0,
  result = princes_st
)

# neatnet (skeletonization) variants
t1 = Sys.time()
benchmark$neatnet_d8 = list(
  name = "neatnet (dist=8)",
  time = as.numeric(Sys.time() - t1),
  result = neatnet(princes_st, dist = 8)
)

t1 = Sys.time()
benchmark$neatnet_d12 = list(
  name = "neatnet (dist=12)",
  time = as.numeric(Sys.time() - t1),
  result = neatnet(princes_st, dist = 12)
)

# sfnetworks variants (already computed above)
benchmark$sfn_eps20 = list(
  name = "sfnetworks (eps=20)",
  time = time_eps20,
  result = results$eps20
)

benchmark$sfn_eps35 = list(
  name = "sfnetworks (eps=35)",
  time = time_eps35,
  result = results$eps35
)

benchmark$sfn_eps50 = list(
  name = "sfnetworks (eps=50)",
  time = time_eps50,
  result = results$eps50
)

# Build comparison table
comparison = data.frame(
  Approach = sapply(benchmark, `[[`, "name"),
  Time_s = sapply(benchmark, `[[`, "time"),
  Features = sapply(benchmark, function(b) nrow(b$result)),
  Vertices = sapply(benchmark, function(b) count_vertices(b$result)),
  Length_km = sapply(benchmark, function(b) round(sum(as.numeric(st_length(b$result)))/1000, 2)),
  stringsAsFactors = FALSE
)

# Calculate derived metrics
comparison$Reduction_pct = round((1 - comparison$Features / comparison$Features[1]) * 100, 1)
comparison$Segs_per_sec = ifelse(comparison$Time_s > 0, 
                                  round(comparison$Features[1] / comparison$Time_s, 0), 
                                  NA)

# Print table
cat("=== Network Simplification Benchmark ===\n\n")
print(comparison, row.names = FALSE)
```

### Summary

The table above shows:

- **Time_s**: Processing time in seconds
- **Features**: Number of line segments in the output
- **Vertices**: Total number of coordinate points
- **Length_km**: Total network length in kilometers
- **Reduction_pct**: Percentage reduction in features vs original
- **Segs_per_sec**: Processing speed (input segments per second)

**Key findings:**

- `sfnetworks (eps=50)` achieves the best simplification (~90% reduction) while maintaining network connectivity
- Larger `eps` values merge more junctions, reducing complexity
- The sfnetworks approach is faster and produces cleaner results than skeletonization for this use case
